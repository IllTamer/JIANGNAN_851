#include "../../main.h"

// 装载问题 —— 回溯法
// 有一批一共n个集装箱要装上2艘重量分别为c1,c2的，轮船，其中集装箱i的重量为wi，
//      且所有集装箱的重量和<=c1+c2。要求确定是否有一个合理的装载方案将这n个集装箱
//      都装上船。

// 子集树 https://www.cnblogs.com/youxin/p/4316325.html
//      当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，
//      相应的解空间称为子集树。例如，那个物品的0-1背包问题所相应的解空间树
//      就是一颗子集树。这类子集问题通常有2^n个叶节点，其节点总个数为2^(n+1)-1。
//      遍历子集树的任何算法均需要O(2^n)的计算时间。
//void backtrack (int t)
//{
//    if (t>n) output(x);
//    else
//        for (int i=0;i<=1;i++) {
//            x[t]=i;
//            if (legal(t)) backtrack(t+1);
//        }
//}

int n,  // 集装箱数
c,      // 第一艘轮船的载重量
cW,     // 从第一层到当前层，选择了的集装箱重量之和
bestW,  // 当前最优集装箱重量之和
r,      // 剩余集装箱重量(默认为集装箱重量和)

*x,     // 当前解。x[i]=1表示第i个集装箱选入第一艘船，=0表示选入第二艘
*bestX, // 当前最优解
*w;     // 集装箱重量数组
/**
 * 解空间：子集树
 *      左子树 —— 装入第一艘
 *      右子树 —— 装入第二艘
 * @param i 表示第i个集装箱，即递归到第i层
 * */
void backtrace(int i) {
    // 到达叶子节点
    if (i > n) {
        // 如果当前载重更优，更新最优载重、最优解
        if (cW > bestW) {
            bestW = cW;
            for (int j = 1; j <= n; ++ j) bestX[j] = x[j];
        }
        return;
    }
    // <更新剩余集装箱重量（减去当前货物重量w[i]>
    r -= w[i];
    // 当前货物重量合法（范围内）-> 搜索左子树
    if (cW+w[i] <= c) {
        x[i] = 1;
        cW += w[i]; // <更新状态>
        backtrace(i+1);
        cW -= w[i]; // <恢复状态>
    }
    // 不选当前货物，已选物品+剩余所有 > 最优值 -> 搜索右子树
    // （若已选物品+剩余所有 <= 最优值，则没有搜索必要
    if (cW+r > bestW) {
        x[i] = 0; // 装入第二艘
        backtrace(i+1);
    }
    // <恢复剩余集装箱重量>
    r += w[i];
}